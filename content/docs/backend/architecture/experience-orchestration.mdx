---
title: Experience Orchestration Architecture
description: Forever-Live Recommendation System with Experience Orchestration
---

# Experience Orchestration System - Complete Architecture

## ğŸ¯ Overview

This document describes the **Forever-Live Recommendation System** with **Experience Orchestration** that personalizes every page, section, and component in your application based on real-time user behavior.

## ğŸ—ï¸ System Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        Web[Web App]
        Mobile[Mobile App]
    end

    subgraph "API Layer"
        ExperienceAPI[Experience Orchestrator API]
        SearchAPI[Search API]
        TrackAPI[Event Tracking API]
    end

    subgraph "Experience Engine"
        Intent[Intent Inference]
        SectionRanker[Section Ranking]
        ComponentRanker[Component Ranking]
        Scorer[Unified Scorer]
        Fatigue[Diversity & Fatigue Control]
    end

    subgraph "Real-Time State (Redis)"
        UserState[User State]
        SessionState[Session State]
        Counters[Live Counters]
        FatigueState[Fatigue Tracking]
    end

    subgraph "Search & Retrieval"
        OpenSearch[OpenSearch/Bonsai]
        ItemIndex[Item Index]
    end

    subgraph "Recommendation Engine"
        CandidateGen[Candidate Generator]
        FeatureStore[Feature Store]
        UserFeatures[User Features]
        ItemFeatures[Item Features]
    end

    subgraph "Analytics & Storage"
        EventsDB[(Events DB)]
        ExperienceDB[(Experience DB)]
        MetricsDB[(Metrics DB)]
    end

    subgraph "Background Processing (Celery)"
        EventConsumer[Event Consumers]
        Aggregator[Feature Aggregators]
        MetricsAgg[Metrics Aggregator]
    end

    Web --> ExperienceAPI
    Mobile --> ExperienceAPI

    ExperienceAPI --> Intent
    Intent --> SectionRanker
    SectionRanker --> ComponentRanker
    ComponentRanker --> Scorer
    Scorer --> Fatigue
    Fatigue --> ExperienceAPI

    ExperienceAPI --> UserState
    ExperienceAPI --> SessionState
    UserState --> ExperienceAPI
    SessionState --> ExperienceAPI

    SectionRanker --> CandidateGen
    CandidateGen --> FeatureStore
    FeatureStore --> UserFeatures
    FeatureStore --> ItemFeatures

    SectionRanker --> OpenSearch
    OpenSearch --> ItemIndex

    TrackAPI --> EventConsumer
    EventConsumer --> EventsDB
    EventConsumer --> UserState

    EventsDB --> Aggregator
    Aggregator --> FeatureStore
    Aggregator --> MetricsAgg
    MetricsAgg --> MetricsDB

    ExperienceAPI --> ExperienceDB
```

## ğŸ“Š Data Flow

### 1. Experience Generation Flow

```
User Request
    â†“
GET /api/experience/page/home/
    â†“
Experience Orchestrator
    â”œâ”€ Infer Intent (discovery/task_driven/consumption)
    â”œâ”€ Generate Candidate Sections
    â”œâ”€ Score Sections (user affinity + context + freshness + popularity)
    â”œâ”€ Apply Diversity & Fatigue Control
    â”œâ”€ Populate Items (from recommendation/search)
    â””â”€ Return Personalized Experience
    â†“
Track Render (ExperienceRender model)
    â†“
Update Redis State (fatigue, counters)
```

### 2. Interaction Tracking Flow

```
User Interaction (click, view, scroll)
    â†“
POST /api/experience/interactions/
    â†“
Save Interaction (ExperienceInteraction model)
    â†“
Update Redis State
    â”œâ”€ Increment item view/click counts
    â”œâ”€ Update user recent items
    â”œâ”€ Track section interaction
    â””â”€ Update session behavior
    â†“
Trigger Celery Task (update features)
    â†“
Update UserFeature/ItemFeature
```

### 3. Analytics Aggregation Flow

```
Periodic Task (every 6 hours)
    â†“
Aggregate Section Metrics
    â”œâ”€ Calculate CTR (clicks / views)
    â”œâ”€ Calculate avg dwell time
    â”œâ”€ Calculate engagement score
    â””â”€ Store in ExperienceSectionMetrics
    â†“
Used for:
    â”œâ”€ Section performance monitoring
    â”œâ”€ A/B testing
    â””â”€ Model improvement
```

## ğŸ”‘ Key Concepts

### 1. Intent Inference

Different pages have different user intents:

| Page | Intent | Focus |
|------|--------|-------|
| home | discovery | Exploration, variety |
| search | task_driven | Relevance, speed |
| category | exploration | Similar items |
| reading | consumption | Continue reading, related |
| profile | retention | Personalized picks |

### 2. Section Scoring

Every section gets a score based on:

- **User Affinity (35%)**: How much user likes this section type
- **Context Relevance (25%)**: How relevant to current page/intent
- **Freshness (15%)**: How new/recent the content is
- **Popularity (15%)**: How popular the section is
- **Business Weight (10%)**: Business-defined priority

### 3. Fatigue Control

Prevents over-showing same sections:

- Track how many times user saw section
- Apply penalty: `score *= (1.0 - fatigue_penalty)`
- Max penalty: 30%
- Reset after TTL expires (1 hour)

### 4. Diversity Control

Ensures variety:

- Don't repeat same section type
- Reduce priority for duplicates
- Skip if priority too low after penalty

## ğŸ—„ï¸ Database Schema

### Experience Models

```python
ExperienceRender
â”œâ”€ user (FK)
â”œâ”€ session_id
â”œâ”€ page
â”œâ”€ intent
â”œâ”€ sections (JSON)
â”œâ”€ context (JSON)
â””â”€ created_at

ExperienceInteraction
â”œâ”€ user (FK)
â”œâ”€ session_id
â”œâ”€ render (FK)
â”œâ”€ interaction_type
â”œâ”€ section_type
â”œâ”€ item_id
â”œâ”€ position
â”œâ”€ dwell_time
â”œâ”€ scroll_depth
â””â”€ created_at

ExperienceSectionMetrics
â”œâ”€ section_type
â”œâ”€ page
â”œâ”€ period_start
â”œâ”€ period_end
â”œâ”€ total_renders
â”œâ”€ total_interactions
â”œâ”€ click_through_rate
â”œâ”€ avg_dwell_time
â”œâ”€ engagement_score
â””â”€ updated_at
```

## ğŸ”´ Redis State Schema

### Key Patterns

```
# User State
exp:user:{user_id}:recent_items          # List of recent item IDs
exp:user:{user_id}:sections:{type}        # Section interactions
exp:user:{user_id}:interests              # Category interest scores

# Fatigue Control
exp:fatigue:{user_id}:{section_type}:{item_id}  # Fatigue count

# Item Counters
exp:item:{item_id}:views                  # View count
exp:item:{item_id}:clicks                 # Click count

# Session State
exp:session:{session_id}:state            # Session state
exp:session:{session_id}:behavior         # Session behaviors

# Search Trends
exp:search:query:{query}                  # Query popularity
exp:search:user:{user_id}:{query}         # User query history
```

### TTLs

- User state: 24 hours
- Session state: 1 hour
- Item counters: 24 hours
- Fatigue: 1 hour
- Recent items: 24 hours

## ğŸ”„ Integration Points

### 1. Recommendation Engine

**Usage:**
- `CandidateGeneratorService.generate_candidates_for_user()` - Personalized picks
- `CandidateGeneratorService.generate_candidates_by_popularity()` - Trending
- `FeatureStoreService.get_or_create_user_features()` - User features

**Data Flow:**
```
Experience Orchestrator
    â†’ Candidate Generator
    â†’ UserFeature/ItemFeature
    â†’ Scored Recommendations
```

### 2. Search App

**Usage:**
- OpenSearch for candidate retrieval
- Search results can be re-ranked by experience scorer
- Search queries tracked for trends

**Data Flow:**
```
Experience Orchestrator
    â†’ OpenSearch Query
    â†’ Candidate Items
    â†’ Re-rank by Experience Scorer
    â†’ Final Items
```

### 3. Event Tracking

**Usage:**
- `UserEvent` model tracks all interactions
- Signals update Redis state automatically
- Celery tasks update features

**Data Flow:**
```
UserEvent Created
    â†’ Signal Handler
    â†’ Update Redis State
    â†’ Trigger Celery Task
    â†’ Update Features
```

## ğŸ“ˆ Performance Considerations

### Caching Strategy

1. **Experience API**: Cache per user/session (5 minutes)
2. **Section Items**: Cache in Redis (1-5 minutes)
3. **User Features**: Cache in Redis (15 minutes)
4. **Item Features**: Cache in Redis (30 minutes)

### Redis Memory

- Monitor Redis memory usage
- Set appropriate TTLs
- Cleanup old keys periodically
- Use Redis eviction policies

### Database Queries

- Use `select_related` and `prefetch_related`
- Index frequently queried fields
- Batch operations where possible
- Use database connection pooling

## ğŸš€ Scaling Considerations

### Horizontal Scaling

- **API Layer**: Stateless, can scale horizontally
- **Celery Workers**: Add more workers for task processing
- **Redis**: Use Redis Cluster for high availability

### Vertical Scaling

- **Database**: Optimize queries, add indexes
- **Redis**: Increase memory for larger state
- **OpenSearch**: Scale cluster for more data

### Performance Targets

- Experience API: < 200ms (p95)
- Redis operations: < 10ms
- Database queries: < 50ms
- Celery tasks: < 5s

## Related Documentation

- [Experience App Documentation](/docs/backend/apps/experience-app)
- [Recommendation Engine Architecture](/docs/backend/architecture/recommendation-engine)
- [Architecture Overview](/docs/backend/architecture/overview)
